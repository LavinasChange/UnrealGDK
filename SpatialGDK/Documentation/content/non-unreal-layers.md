# Non-Unreal layers
<%(TOC)%>

In SpatialOS, you can split up [server-worker](https://docs.improbable.io/unreal/alpha/content/glossary#workers) computation into layers, with each layer of server-worker instances handling a specific and unique aspect of your game. By default, the GDK for Unreal uses a single Unreal server-worker layer to handle all server-side computation. However, you can set up additional non-Unreal layers, made up of server-worker instances that do not use Unreal or the GDK.

You can use non-Unreal layers to modularize your game’s functionality so you can re-use the functionality across different games. For example, you could use a non-Unreal layer written in Python that interacts with a database or other 3rd party service, such as [Firebase](https://firebase.google.com/) or [PlayFab](https://playfab.com/).

## Layers in SpatialOS
A SpatialOS layer has two elements;

* a group of SpatialOS [component definitions](https://docs.improbable.io/unreal/alpha/content/glossary#spatialos-component),
* server-worker instances of a worker type that have [write access authority](https://docs.improbable.io/unreal/alpha/content/glossary#authority) over the group of components.

(For information on layers in non-GDK SpatialOS development, see the [SpatialOS documentation](https://docs.improbable.io/reference/latest/shared/worker-configuration/layers#layers).)

## How to integrate non-Unreal layers into your game
In order to interact with each other, Unreal and non-Unreal server-worker instances need to send and receive updates to and [commands](https://docs.improbable.io/reference/latest/shared/glossary#command) for the same SpatialOS components. We recommend that you define the SpatialOS components used by non-Unreal worker instances manually in [schema](https://docs.improbable.io/unreal/alpha/content/glossary#schema) files, separate from those automatically generated by the GDK.  This is because:

* SpatialOS command data in GDK-generated schema files is encoded as byte strings, making deserialization of commands in non-Unreal server-worker types more difficult.
* It aids portability; you can more easily re-use any non-Unreal server-worker types when you have an accompanying schema file.

Default single Unreal layer development doesn’t accommodate schema files that haven’t been generated by the SDK, so you need to set your game up to handle this.

### How to set up interaction
To set up your game to interact with SpatialOS components defined outside the GDK (external SpatialOS components), you use the following:

* To send SpatialOS component updates and commands, use methods defined in the `SpatialWorkerConnection.h` file (described in the examples section below).
* To receive [network operations](https://docs.improbable.io/reference/latest/shared/design/operations) for external SpatialOS components, you must provide custom callbacks for specific component IDs and operation types. The GDK then forwards the operations to your callbacks. (This is described in the examples section below.)


>**TIP:** If you’re using schema from outside the GDK, you can customise [snapshot generation](https://docs.improbable.io/unreal/alpha/content/generating-a-snapshot#when-to-generate-a-snapshot) from the GDK toolbar’s  **Snapshot** button. This is to serialize additional entities with these external components which the default Unreal snapshot generation cannot currently do. See [Add to the snapshot](#add-to-the-snapshot) below for how to do this.

#### Send data
You set up your game to send SpatialOS component updates, command requests, and command responses directly using the `SpatialWorkerConnection.h` public methods:

* `void SendComponentUpdate(Worker_EntityId EntityId, const Worker_ComponentUpdate* ComponentUpdate);`
* `Worker_RequestId SendCommandRequest(Worker_EntityId EntityId, const Worker_CommandRequest* Request, uint32_t CommandId);`
* `void SendCommandResponse(Worker_RequestId RequestId, const Worker_CommandResponse* Response);`

You access these methods via a reference to the net driver, as shown below:

`SpatialWorkerConnection connection = Cast<USpatialNetDriver>(World->GetNetDriver())->Connection;`

There is a basic example in the _Examples_ section below. For more examples of how to construct component updates, command requests, and more, see the SpatialOS documentation on  [serialization in the Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/serialization).

#### Receive data

>**Note:** Your external SpatialOS components must have an ID between 1000 and 2000 to be registered by the pipeline.

You set up your game to receive network operations using the `SpatialNetDriver::AddOpCallback` function. This function is paramaterised with a SpatialOS component ID and a callback function reference with the following type:

`const TFunction<void(Worker_ComponentId, const Worker_Op*)>`

where `Worker_ComponentId` and `Worker_Op` are types defined in the [Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/reference). You

You'll need to register your callbacks before the Unreal worker connects to the SpatialOS runtime to avoid missing any operations.

You can deregister your callbacks at runtime using the `SpatialNetDriver::RemoveOpCallback` function and passing the `CallbackId` parameter returned by the corresponding call to `SpatialNetDriver::AddOpCallback`.

There is a basic example in the _Examples_ section below. For more examples of how to deserialize the `Worker_Op` type see the SpatialOS documentation on [serialization in the Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/serialization).

#### Add to the snapshot
You can customize snapshot generation by creating a class derived from the GDK `USnapshotGenerationTemplate` base class, and implementing the method below. You have the responsibility of incrementing the `NextEntityId` reference. If you don’t, snapshot generation will fail by attempting to add multiple entities to the snapshot with the same ID.
```  
    * Write to the snapshot generation output stream.
    * @param OutputStream the output stream for the snapshot being created.
    * @param NextEntityId the next available entity ID in the snapshot, this reference should be incremented appropriately.
    * @return bool the success of writing to the snapshot output stream, this is returned to the overall snapshot generation.
    **/
bool WriteToSnapshotOutput(Worker_SnapshotOutputStream* OutputStream, Worker_EntityId& NextEntityId);
```


There is a basic example in the _Examples_ section below. For more examples of how to deserialize see the SpatialOS documentation on  [serialization in the Worker SDK in C’s API](https://docs.improbable.io/reference/latest/capi/serialization).

### Examples
Below is a simple example schema file which a non-Unreal layer could use to track player statistics:

```
package improbable.session;

type MyRequest {
  string player_name = 1;
}
type MyResponse {}

component Session {
    id = 1337;
    uint32 player_count = 1;
    command MyResponse some_command(My_Request);
}
```

#### Send data
You could serialize and send a component update in your Unreal project code in the following way:
 
```
void SendSomeUpdate(Worker_EntityId TargetEntityId, Worker_ComponentId ComponentId)
{
    Worker_ComponentUpdate Update = {};
    Update.component_id = ComponentId;
    Update.schema_type = Schema_CreateComponentUpdate(ComponentId);
    Schema_Object* FieldsObject = Schema_GetComponentUpdateFields(Update.schema_type);
    Schema_AddInt32(FieldsObject, 1, ++UnrealCounter);
    Cast<USpatialNetDriver>(World->GetNetDriver())->Connection->SendComponentUpdate(TargetEntityId, &Update);
}
```


You could serialize and send a command response in your Unreal project code in the following way:


```
Worker_RequestId SendSomeCommandRequest(Worker_EntityId TargetEntityId, Worker_ComponentId ComponentId, Schema_FieldId CommandId) {
    Worker_CommandResponse Response = {};
    Response.component_id = ComponentId;
    Response.schema_type = Schema_CreateCommandResponse(ComponentId, CommandId);
    Schema_Object* ResponseObject = Schema_GetCommandResponseObject(Response.schema_type);
    const char* Text = "Hello World.";
    Schema_AddBytes(ResponseObject, 1, (const uint8_t*)Text, sizeof(char) * strlen(Text));
    Cast<USpatialNetDriver>(World->GetNetDriver())->Connection->SendCommandResponse(TargetEntityId, &Response);
}
```


#### Receive data
You could receive and deserialize a component update and command request in your Unreal project code in the following way:
```
void OnAddComponent(Worker_ComponentId ComponentId, const Worker_Op* Op)
{
    Worker_ComponentUpdate Update = Op->component_update;
    
    // example deserialization logic
}

void OnCommandRequest(const Worker_CommandRequestOp& Op) override
{
    Worker_CommandRequest Request = Op->command_request;

    // example deserialization logic

    Cast<USpatialNetDriver>(World->GetNetDriver())->Connection->SendCommandResponse(Op.request_id, &Response);
}
}
```

#### Add to the snapshot
You could add a new entity with the given component in your Unreal project code in the following way:

```
UCLASS()
class SPATIALGDK_API USessionEntitySnapshotGeneration : USnapshotGenerationTemplate
{
    GENERATED_BODY()

public:
    bool WriteToSnapshotOutput(Worker_SnapshotOutputStream* OutputStream, Worker_Entity& NextEntityId) override
    {
        Worker_Entity SomeEntity;
        SomeEntity.entity_id = NextEntityId;
        TArray<Worker_ComponentData> Components;
        const WorkerAttributeSet ExternalWorkerAttributeSet{ TArray<FString>{TEXT("some_external_worker_type")} };
        const WorkerRequirementSet ExternalWorkerPermission{ ExternalWorkerAttributeSet};
        const WorkerRequirementSet AnyWorkerPermission{ {SpatialConstants::UnrealClientAttributeSet, SpatialConstants::UnrealServerAttributeSet, ExternalWorkerAttributeSet} };
        WriteAclMap ComponentWriteAcl;
        ComponentWriteAcl.Add(SpatialConstants::POSITION_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(SpatialConstants::METADATA_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(SpatialConstants::PERSISTENCE_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(SpatialConstants::ENTITY_ACL_COMPONENT_ID, SpatialConstants::UnrealServerPermission);
        ComponentWriteAcl.Add(1337, ExternalWorkerPermission);

        // Serialize SomeComponent data
        Worker_ComponentData SomeComponentComponentData{};
        FromUnrealComponentData.component_id = 1337;
        FromUnrealComponentData.schema_type = Schema_CreateComponentData(1337);
        Schema_Object* FromUnrealComponentDataObject = Schema_GetComponentDataFields(FromUnrealComponentData.schema_type);
        Schema_AddInt32(FromUnrealComponentDataObject, 1, 1); // set some_counter to 1 initially

        Components.Add(improbable::Position(improbable::Origin).CreatePositionData());
        Components.Add(improbable::Metadata(TEXT("SessionManager")).CreateMetadataData());
        Components.Add(improbable::Persistence().CreatePersistenceData());
        Components.Add(improbable::EntityAcl(AnyWorkerPermission, ComponentWriteAcl).CreateEntityAclData());
        Components.Add(SessionComponentData);
        Components.Add(FromUnrealComponentData);

        SomeEntity.component_count = Components.Num();
        SomeEntity.components = Components.GetData();

        bool bSuccess = Worker_SnapshotOutputStream_WriteEntity(OutputStream, &SomeEntity) != 0;
        if (bSuccess)
        {
            NextEntityId++;
        }
        return bSuccess;
    }
}
```

<br/>
------------
2019-03-15 Page added with full editorial review
