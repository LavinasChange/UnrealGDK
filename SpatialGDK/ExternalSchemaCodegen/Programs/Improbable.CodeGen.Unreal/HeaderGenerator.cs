using Improbable.CodeGen.Base;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Improbable.CodeGen.Unreal
{
    public static class HeaderGenerator
    {
        private static string DefaultHeaderIncludes = string.Join(Environment.NewLine, new []{
            "#include <cstddef>",
            "#include <cstddef>",
            "#include <cstdint>",
            "#include <functional>",
            "#include <set>",
            "#include <string>",
            "#include \"CoreMinimal.h\"",
            "#include \"Utils/SchemaOption.h\"",
            "#include <WorkerSDK/improbable/c_schema.h>",
            "#include <WorkerSDK/improbable/c_worker.h>",
            $"#include \"{UnrealGenerator.RelativeIncludePrefix}{HelperFunctions.HeaderPath}\""
        });
    
        public static string GenerateHeader(TypeDescription type, List<TypeDescription> types, Dictionary<string, TypeGeneratedCode> allGeneratedTypeContent, Bundle bundle)
        {
            var builder = new StringBuilder();
            var sourceRef = bundle.SchemaBundle.SourceMapV1.SourceReferences[type.QualifiedName];
            var allTopLevelTypes = Types.SortTopLevelTypesTopologically(type, types, bundle);
            var allNestedEnums = Types.GetRecursivelyNestedEnums(type);
            var typeNamespaces = Text.GetNamespaceFromTypeName(type.QualifiedName);
            var requiredIncludes = Types.GetRequiredTypeIncludes(type, bundle).Select(inc => $"#include \"{UnrealGenerator.RelativeIncludePrefix}{inc}\"");

            builder.AppendLine($"// Generated by {UnrealGenerator.GeneratorTitle}");
            builder.Append(Environment.NewLine);

            builder.AppendLine($"#pragma once");

            // Includes
            builder.Append(Environment.NewLine);
            builder.AppendLine(DefaultHeaderIncludes);
            builder.Append(Environment.NewLine);
            if (requiredIncludes.Count() > 0)
            {
                builder.AppendLine(string.Join(Environment.NewLine, requiredIncludes));
                builder.Append(Environment.NewLine);
            }

            // Namespaces
            builder.AppendLine(string.Join(Environment.NewLine, typeNamespaces.Select(t => $"namespace {t} {{")));
            builder.Append(Environment.NewLine);

            // Forward declarations
            foreach (var topLevelType in allTopLevelTypes)
            {
                builder.AppendLine($"class {Types.GetTypeClassDefinitionName(topLevelType.QualifiedName, bundle)};");
            }
            builder.Append(Environment.NewLine);

            // Declare nested enums
            if (allNestedEnums.Count() > 0)
            {
                builder.Append(Environment.NewLine);
                var enumDefs = allNestedEnums.Select(enumDef => EnumGenerator.GenerateEnum(Types.GetTypeClassDefinitionName(enumDef.Identifier.QualifiedName, bundle), enumDef, bundle).Replace($"enum {enumDef.Identifier.Name}", $"class {enumDef.Identifier.Name}_{enumDef.Identifier.Name}"));
                builder.AppendLine(string.Join(Environment.NewLine, enumDefs));
                builder.Append(Environment.NewLine);
            }

            // Declare top-level type classes
            builder.AppendJoin(Environment.NewLine, allTopLevelTypes.Select(topLevelType => GenerateTypeClass(Types.GetTypeClassDefinitionName(topLevelType.QualifiedName, bundle), types.Find(t => t.QualifiedName == topLevelType.QualifiedName), bundle)));
            builder.Append(Environment.NewLine);

            // Declare hashing structs (and for nested types)
            builder.AppendJoin(Environment.NewLine, allTopLevelTypes.Select(nestedType => GenerateHashFunction(Types.GetTypeClassDefinitionQualifiedName(nestedType.QualifiedName, bundle))));
            builder.Append(Environment.NewLine);

            builder.AppendLine(string.Join(Environment.NewLine, typeNamespaces.Reverse().Select(t => $"}} // namespace {t}")));

            return builder.ToString();
        }

        private static string GenerateTypeClass(string name, TypeDescription type, Bundle bundle)
        {
            var sourceRef = bundle.SchemaBundle.SourceMapV1.SourceReferences[type.QualifiedName];
            var hasFields = type.Fields.Count > 0;

            var builder = new StringBuilder();

            builder.AppendLine($"// Generated from {sourceRef.FilePath}({sourceRef.Line},{sourceRef.Column})");
            builder.AppendLine($"class {name} : public {(type.IsComponent ? "SpatialComponent" : "SpatialType")}");
            builder.AppendLine("{");
            builder.AppendLine("public:");
            if (type.IsComponent)
            {
                builder.AppendLine(Text.Indent(1, $"static const Worker_ComponentId ComponentId = {type.ComponentId.Value};"));
                builder.Append(Environment.NewLine);
            }
            if (type.NestedTypes.Count > 0)
            {
                builder.AppendLine(Text.Indent(1, "// Nested types"));
                builder.AppendJoin(Environment.NewLine, type.NestedTypes.Select(nestedType => Text.Indent(1, $"using {nestedType.Name} = {Types.GetTypeClassDefinitionName(nestedType.QualifiedName, bundle)};")));
                builder.AppendLine(Environment.NewLine);
            }
            if (type.NestedEnums.Count > 0)
            {
                builder.AppendLine(Text.Indent(1, "// Nested enums"));
                builder.AppendJoin(Environment.NewLine, type.NestedEnums.Select(nestedEnum => Text.Indent(1, $"using {nestedEnum.Identifier.Name} = {Types.GetTypeClassDefinitionName(nestedEnum.Identifier.QualifiedName, bundle)};")));
                builder.AppendLine(Environment.NewLine);
            }
            builder.AppendLine(Text.Indent(1, GenerateConstructorsAndAssignmentsDeclarations(name, type, bundle)));
            builder.AppendLine(Text.Indent(1, GenerateEquatablesDeclarations(name, type, bundle).ToString()));
            builder.AppendLine(Text.Indent(1, GenerateSerializerDeclarations(name, type, bundle)));

            if (hasFields)
            {
                builder.Append(Environment.NewLine);
                builder.AppendLine(Text.Indent(1, GenerateFieldAccessorsDeclarations(name, type, bundle)));
                builder.Append(Environment.NewLine);
                builder.AppendLine("private:");
                builder.AppendLine(Text.Indent(1, GeneratePrivateFieldDeclarations(type, bundle)));
            }

            if (type.IsComponent)
            {
                builder.Append(Environment.NewLine);
                builder.AppendLine("public:");

                builder.AppendLine(Text.Indent(1, GenerateComponentUpdateDeclaration(name, type, bundle)));

                if (bundle.Components[type.QualifiedName].CommandDefinitions.Count > 0)
                {
                    builder.AppendLine(Environment.NewLine);
                    builder.AppendLine(Text.Indent(1, GenerateComponentCommandsDeclaration(type, bundle)));
                }

                builder.Append(Environment.NewLine);
                builder.AppendLine(Text.Indent(1, $"using AddComponentOp = ::improbable::AddComponentOp<{name}>;"));
                builder.AppendLine(Text.Indent(1, $"using RemoveComponentOp = ::improbable::RemoveComponentOp<{name}>;"));
                builder.AppendLine(Text.Indent(1, $"using ComponentUpdateOp = ::improbable::ComponentUpdateOp<Update>;"));
                builder.AppendLine(Text.Indent(1, $"using AuthorityChangeOp = ::improbable::AuthorityChangeOp<{name}>;"));
            }
            builder.AppendLine("};");

            return builder.ToString();
        }

        private static string GenerateConstructorsAndAssignmentsDeclarations(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();

            // If type has members, generate full constructor
            if (type.Fields.Count > 0)
            {
                var parameters = string.Join(", ", type.Fields.Select(f => $"{Types.GetFieldTypeAsCpp(f, bundle)} {Text.SnakeCaseToPascalCase(f.Identifier.Name)}"));
                builder.AppendLine($@"// Creates a new instance with specified arguments for each field.");
                builder.AppendLine($@"{name}({parameters});");
            }

            builder.AppendLine($@"// Creates a new instance with default values for each field.");
            builder.AppendLine($@"{name}();");
            builder.AppendLine($@"// Creates a new instance with default values for each field. This is");
            builder.AppendLine($@"// equivalent to a default-constructed instance.");
            builder.AppendLine($@"static {name} Create() {{ return {{}}; }}");
            builder.AppendLine($@"// Copyable and movable.");
            builder.AppendLine($@"{name}({name}&&) = default;");
            builder.AppendLine($@"{name}(const {name}&) = default;");
            builder.AppendLine($@"{name}& operator=({name}&&) = default;");
            builder.AppendLine($@"{name}& operator=(const {name}&) = default;");
            builder.AppendLine($@"~{name}() = default;");

            return builder.ToString();
        }

        private static string GenerateEquatablesDeclarations(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();
            builder.AppendLine($"bool operator==(const {name}&) const;");
            builder.AppendLine($"bool operator!=(const {name}&) const;");
            return builder.ToString();
        }

        private static string GenerateSerializerDeclarations(string name, TypeDescription type, Bundle bundle)
        {
            var argType = type.IsComponent ? "Schema_ComponentData" : "Schema_Object";
            var argName = type.IsComponent ? "ComponentData" : "SchemaObject";

            var builder = new StringBuilder();
            builder.AppendLine($"// Serialize this object data into the C API argument");
            builder.AppendLine($"void Serialize({argType}* {argName}) const override;");
            builder.Append(Environment.NewLine);
            builder.AppendLine($"// Deserialize the C API object argument into an instance of this class and return it");
            builder.AppendLine($"static {name} Deserialize({argType}* {argName});");
            return builder.ToString().TrimEnd();
        }

        private static string GenerateFieldAccessorsDeclarations(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();

            foreach (var field in type.Fields)
            {
                var qualifiedFieldType = Types.GetFieldTypeAsCpp(field, bundle);
                builder.AppendLine($"// Field {Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {field.FieldId}");
                builder.AppendLine($"{Types.GetConstAccessorTypeModification(field, bundle)} Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}() const;");
                builder.AppendLine($"{qualifiedFieldType}& Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}();");
                builder.AppendLine($"{name}& Set{Text.SnakeCaseToPascalCase(field.Identifier.Name)}({Types.GetConstAccessorTypeModification(field, bundle)});");
                builder.Append(Environment.NewLine);
            }

            return builder.ToString().TrimEnd();
        }

        private static string GeneratePrivateFieldDeclarations(TypeDescription type, Bundle bundle)
        {
            var fieldText = new StringBuilder();

            foreach (var field in type.Fields)
            {
                var qualifiedFieldType = Types.GetFieldTypeAsCpp(field, bundle);
                fieldText.AppendLine($"{qualifiedFieldType} _{Text.SnakeCaseToPascalCase(field.Identifier.Name)};");
            }

            return fieldText.ToString().TrimEnd();
        }

        private static string GenerateComponentCommandsDeclaration(TypeDescription type, Bundle bundle)
        {
            var qualifiedType = Types.GetQualifiedTypeName(type);
            var builder = new StringBuilder();

            builder.AppendLine("class Commands");
            builder.AppendLine("{");
            builder.AppendLine("public:");
            foreach (var command in bundle.Components[type.QualifiedName].CommandDefinitions)
            {
                builder.AppendLine(Text.Indent(1, $"class {Text.SnakeCaseToPascalCase(command.Identifier.Name)}"));
                builder.AppendLine(Text.Indent(1, "{"));
                builder.AppendLine(Text.Indent(1, "public:"));
                builder.AppendLine(Text.Indent(2, $"static const Schema_FieldId CommandIndex = {command.CommandIndex};"));
                builder.AppendLine(Text.Indent(2, "struct Request"));
                builder.AppendLine(Text.Indent(2, "{"));
                builder.AppendLine(Text.Indent(3, $"using Type = {Types.GetQualifiedTypeName(command.RequestType, bundle)};"));
                builder.AppendLine(Text.Indent(3, $"Request(Type Data) : Data{{ Data }} {{}}"));
                builder.AppendLine(Text.Indent(3, "Type Data;"));
                builder.AppendLine(Text.Indent(2, "};"));
                builder.AppendLine(Text.Indent(2, "struct Response"));
                builder.AppendLine(Text.Indent(2, "{"));
                builder.AppendLine(Text.Indent(3, $"using Type = {Types.GetQualifiedTypeName(command.ResponseType, bundle)};"));
                builder.AppendLine(Text.Indent(3, $"Response(Type Data) : Data{{ Data }} {{}}"));
                builder.AppendLine(Text.Indent(3, "Type Data;"));
                builder.AppendLine(Text.Indent(2, "};"));
                builder.AppendLine(Text.Indent(2, $"using RequestOp = ::improbable::CommandRequestOp<Request>;"));
                builder.AppendLine(Text.Indent(2, $"using ResponseOp = ::improbable::CommandResponseOp<Response>;"));     
                builder.AppendLine(Text.Indent(1, "};"));
            }
            builder.AppendLine("};");

            return builder.ToString().TrimEnd();
        }

        private static string GenerateComponentUpdateDeclaration(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();

            builder.AppendLine($@"class Update : public SpatialComponentUpdate");
            builder.AppendLine("{");
            builder.AppendLine("public:");

            builder.AppendLine(Text.Indent(1, GenerateUpdateMainDeclarations(type)));

            if (type.Fields.Count + type.Events.Count > 0 )
            {
                builder.AppendLine(Text.Indent(1, GenerateOptionalFieldAccessorsDeclarations(name, type, bundle)));
                builder.AppendLine("private:");
                builder.AppendLine(Text.Indent(1, GeneratePrivateCommandUpdateFieldDeclarations(type, bundle)));
            }

            builder.AppendLine("};");

            return builder.ToString().TrimEnd();
        }

        private static string GenerateUpdateMainDeclarations(TypeDescription type)
        {
            var qualifiedType = Types.GetQualifiedTypeName(type);
            var builder = new StringBuilder();

            builder.AppendLine($@"// Creates a new instance with default values for each field.");
            builder.AppendLine($@"Update() = default;");
            builder.AppendLine($@"// Creates a new instance with default values for each field. This is");
            builder.AppendLine($@"// equivalent to a default-constructed instance.");
            builder.AppendLine($@"static Update Create() {{ return {{}}; }}");
            builder.AppendLine($@"// Copyable and movable.");
            builder.AppendLine($@"Update(Update&&) = default;");
            builder.AppendLine($@"Update(const Update&) = default;");
            builder.AppendLine($@"Update& operator=(Update&&) = default;");
            builder.AppendLine($@"Update& operator=(const Update&) = default;");
            builder.AppendLine($@"~Update() = default;");
            builder.AppendLine($@"bool operator==(const Update&) const;");
            builder.AppendLine($@"bool operator!=(const Update&) const;");
            builder.Append(Environment.NewLine);
            builder.AppendLine($@"// Creates an Update from a {qualifiedType} object.");
            builder.AppendLine($@"static Update FromInitialData(const {qualifiedType}& Data);");
            builder.Append(Environment.NewLine);
            builder.AppendLine($@"/**");
            builder.AppendLine($@"  * Converts to a {qualifiedType}");
            builder.AppendLine($@"  * object. It is an error to call this function unless *all* of the optional fields in this");
            builder.AppendLine($@"  * update are filled in.");
            builder.AppendLine($@"  */");
            builder.AppendLine($@"{qualifiedType} ToInitialData() const;");
            builder.Append(Environment.NewLine);
            builder.AppendLine($@"/**");
            builder.AppendLine($@"  * Replaces fields in the given {qualifiedType}");
            builder.AppendLine($@"  * object with the corresponding fields in this update, where present.");
            builder.AppendLine($@"  */");
            builder.AppendLine($@"void ApplyTo({qualifiedType}&) const;");
            builder.Append(Environment.NewLine);
            builder.AppendLine($@"// Serialize this update object data into the C API component update argument");
            builder.AppendLine($@"void Serialize(Schema_ComponentUpdate* ComponentUpdate) const override;");
            builder.Append(Environment.NewLine);
            builder.AppendLine($@"// Deserialize the C API component update argument into an instance of this class and return it");
            builder.AppendLine($@"static Update Deserialize(Schema_ComponentUpdate* ComponentUpdate);");

            return builder.ToString();
        }

        private static string GenerateOptionalFieldAccessorsDeclarations(string name, TypeDescription type, Bundle bundle)
        {
            var fieldText = new StringBuilder();

            foreach (var field in type.Fields)
            {
                var qualifiedFieldType = Types.GetFieldTypeAsCpp(field, bundle);
                fieldText.AppendLine($"// Field {Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {field.FieldId}");
                fieldText.AppendLine($"const {Types.CollectionTypesToQualifiedTypes[Types.Collection.Option]}<{qualifiedFieldType}>& Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}() const;");
                fieldText.AppendLine($"{Types.CollectionTypesToQualifiedTypes[Types.Collection.Option]}<{qualifiedFieldType}>& Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}();");
                fieldText.AppendLine($"{name}::Update& Set{Text.SnakeCaseToPascalCase(field.Identifier.Name)}({qualifiedFieldType});");
                fieldText.Append(Environment.NewLine);
            }

            foreach (var _event in type.Events)
            {
                var qualifiedFieldType = Types.GetQualifiedTypeName(_event.Type.Type.QualifiedName);
                fieldText.AppendLine($"// Event {Text.SnakeCaseToPascalCase(_event.Identifier.Name)} = {_event.EventIndex}");
                fieldText.AppendLine($"const {Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<{qualifiedFieldType}>& Get{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List() const;");
                fieldText.AppendLine($"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<{qualifiedFieldType}>& Get{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List();");
                fieldText.AppendLine($"{name}::Update& Add{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}(const {qualifiedFieldType}&);");
                fieldText.Append(Environment.NewLine);
            }

            return fieldText.ToString();
        }

        private static string GeneratePrivateCommandUpdateFieldDeclarations(TypeDescription type, Bundle bundle)
        {
            var fieldText = new StringBuilder();

            foreach (var field in type.Fields)
            {
                var qualifiedFieldType = Types.GetFieldTypeAsCpp(field, bundle);
                fieldText.AppendLine($"{Types.CollectionTypesToQualifiedTypes[Types.Collection.Option]}<{qualifiedFieldType}> _{Text.SnakeCaseToPascalCase(field.Identifier.Name)};");
            }
            foreach (var _event in type.Events)
            {
                fieldText.AppendLine($"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<{Types.GetQualifiedTypeName(_event.Type, bundle)}> _{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List;");
            }

            return fieldText.ToString().TrimEnd();
        }

        private static string GenerateHashFunction(string qualifiedTypeName)
        {
            return $"inline uint32 GetTypeHash(const {qualifiedTypeName}& Value);";
        }
    }
}
