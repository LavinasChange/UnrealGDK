using Improbable.Codegen.Base;
using Improbable.CodeGen.Base;
using System;
using System.Collections.Generic;
using System.Text;

namespace Improbable.CodeGen.Unreal
{
    public static class HelperFunctions
    {
        public static string HeaderPath = $"HelperFunctions.h";
        public static string SourceFile = $"HelperFunctions.cpp";

        public static List<GeneratedFile> GetHelperFunctionFiles()
        {
            return new List<GeneratedFile>
            {
                new GeneratedFile(HeaderPath, GetHelperFunctionHeader()),
                new GeneratedFile(SourceFile, GetHelperFunctionSource())
            };
        }

        private static string GetHelperFunctionHeader()
        {
            var builder = new StringBuilder();

            builder.AppendLine($"// Generated by {UnrealGenerator.GeneratorTitle}");
            builder.Append(Environment.NewLine);
            builder.AppendLine("#pragma once");
            builder.Append(Environment.NewLine);
            builder.AppendLine("#include <cstddef>");
            builder.AppendLine("#include <cstdint>");
            builder.AppendLine("#include <functional>");
            builder.AppendLine("#include <string>");
            builder.AppendLine("#include <vector>");
            builder.AppendLine("#include <improbable/c_schema.h>");
            builder.AppendLine("#include <improbable/c_worker.h>");
            builder.Append(Environment.NewLine);
            builder.AppendLine("#include \"CoreMinimal.h\"");
            builder.Append(Environment.NewLine);

            builder.AppendLine("namespace improbable {");

            builder.AppendLine(Text.Indent(1, "class SpatialType"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(1, "public:"));
            builder.AppendLine(Text.Indent(2, "virtual ~SpatialType() = 0 {};"));
            builder.AppendLine(Text.Indent(2, "virtual void Serialize(Schema_Object* SchemaObject) const = 0;"));
            builder.AppendLine(Text.Indent(1, "};"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, "class SpatialComponent"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(1, "public:"));
            builder.AppendLine(Text.Indent(2, "virtual ~SpatialComponent() = 0 {};"));
            builder.AppendLine(Text.Indent(2, "virtual void Serialize(Schema_ComponentData* ComponentData) const = 0;"));
            builder.AppendLine(Text.Indent(1, "};"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, "class SpatialComponentUpdate"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(1, "public:"));
            builder.AppendLine(Text.Indent(2, "virtual ~SpatialComponentUpdate() = 0 {};"));
            builder.AppendLine(Text.Indent(2, "virtual void Serialize(Schema_ComponentUpdate* ComponentUpdate) const = 0;"));
            builder.AppendLine(Text.Indent(1, "};"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $@"class ExternalSchemaOp
    {{
    public:
		ExternalSchemaOp(Worker_EntityId EntityId) : EntityId{{ EntityId }} {{}}
		Worker_EntityId EntityId;
		virtual ~ExternalSchemaOp() = 0 {{}};
    }};

	template<typename ComponentData>
	class AddComponentOp : public ::improbable::ExternalSchemaOp
	{{
	public:
		AddComponentOp(
			Worker_EntityId EntityId, 
			Worker_ComponentId ComponentId, 
			ComponentData Data) 
		: ExternalSchemaOp( EntityId )
		, ComponentId(ComponentId )
		, Data( Data ) {{}}

		Worker_ComponentId ComponentId; 
		ComponentData Data;
	}};

	template<typename ComponentClass>
	class RemoveComponentOp : public ::improbable::ExternalSchemaOp 
	{{
	public:
		RemoveComponentOp(
			Worker_EntityId EntityId, 
			Worker_ComponentId ComponentId) 
		: ExternalSchemaOp( EntityId )
		, ComponentId( ComponentId ) {{}}

		Worker_ComponentId ComponentId;
	}};

	template<typename ComponentUpdate>
	class ComponentUpdateOp : public ::improbable::ExternalSchemaOp
	{{
	public:
		ComponentUpdateOp(
			Worker_EntityId EntityId, 
			Worker_ComponentId ComponentId, 
			ComponentUpdate Update) 
		: ExternalSchemaOp(EntityId)
		, ComponentId(ComponentId)
		, Update(Update) {{}}

		Worker_ComponentId ComponentId;
		ComponentUpdate Update;
	}};

	template<typename T> // just to differentiate type aliases
	class AuthorityChangeOp : public ::improbable::ExternalSchemaOp
	{{
	public:
		AuthorityChangeOp(
			Worker_EntityId EntityId, 
			Worker_ComponentId ComponentId, Worker_Authority Authority) 
		: ExternalSchemaOp( EntityId )
		, ComponentId( ComponentId )
		, Authority( Authority ) {{}}

		Worker_ComponentId ComponentId;
		Worker_Authority Authority;
	}};

	template<typename RequestData>
	class CommandRequestOp : public ::improbable::ExternalSchemaOp
	{{
	public:
		CommandRequestOp(
			Worker_EntityId EntityId, 
			Worker_RequestId RequestId,
			uint32_t TimeoutMillis, 
			const char* CallerWorkerId, 
			Worker_WorkerAttributes CallerAttributeSet, 
			RequestData Data) 
		: ExternalSchemaOp(EntityId)
		, RequestId(RequestId)
		, TimeoutMillis(TimeoutMillis)
		, CallerWorkerId(CallerWorkerId)
		, CallerAttributeSet(CallerAttributeSet)
		, Data(Data) {{}}

		Worker_RequestId RequestId;
		uint32_t TimeoutMillis;
		const char* CallerWorkerId;
		Worker_WorkerAttributes CallerAttributeSet;
		RequestData Data;
	}};

	template<typename ResponseData>
	class CommandResponseOp : public ::improbable::ExternalSchemaOp
	{{
	public:
		CommandResponseOp(Worker_EntityId EntityId, 
			Worker_RequestId RequestId, 
			uint8_t StatusCode, 
			const char* Message, 
			uint32_t CommandId, 
			ResponseData Data) 
		: ExternalSchemaOp(EntityId)
		, RequestId(RequestId)
		, StatusCode(StatusCode)
		, Message(Message)
		, CommandId(CommandId)
		, Data(Data) {{}}

		Worker_RequestId RequestId;
		uint8_t StatusCode;
		const char* Message;
		uint32_t CommandId;
		ResponseData Data;
	}};"));
            builder.AppendLine(Text.Indent(1, "namespace utils {"));
            builder.AppendLine(Text.Indent(2, $@"// Utility methods for serializing and deserializing string fields"));
            builder.AppendLine(Text.Indent(2, $@"void AddBytes(Schema_Object* SchemaObject, Schema_FieldId FieldId, const TArray<uint8>& Value);"));
            builder.AppendLine(Text.Indent(2, $@"void AddString(Schema_Object* SchemaObject, Schema_FieldId FieldId, FString Value);"));
            builder.AppendLine(Text.Indent(2, $@"TArray<uint8> GetBytes(const Schema_Object* SchemaObject, Schema_FieldId FieldId);"));
            builder.AppendLine(Text.Indent(2, $@"FString GetString(const Schema_Object* SchemaObject, Schema_FieldId FieldId);"));
            builder.AppendLine(Text.Indent(2, $@"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<FString> GetStringList(const Schema_Object* SchemaObject, Schema_FieldId FieldId);"));
            builder.AppendLine(Text.Indent(2, $@"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<TArray<uint8>> GetBytesList(const Schema_Object* SchemaObject, Schema_FieldId FieldId);"));
            builder.AppendLine(Text.Indent(1, $"}} // namespace utils"));
            builder.AppendLine($"}} // namespace improbable");
            builder.Append(Environment.NewLine);

            builder.AppendLine($"inline uint32 GetTypeHash(const TArray<uint8>& Value);");

            return builder.ToString();
        }

        private static string GetHelperFunctionSource()
        {
            var builder = new StringBuilder();

            builder.AppendLine($"// Generated by {UnrealGenerator.GeneratorTitle}");
            builder.Append(Environment.NewLine);
            builder.AppendLine($"#include \"{UnrealGenerator.RelativeIncludePrefix}{HeaderPath}\"");
            builder.Append(Environment.NewLine);

            builder.AppendLine("namespace improbable {");
            builder.AppendLine("namespace utils {");

            builder.AppendLine(Text.Indent(1, "void AddBytes(Schema_Object* SchemaObject, Schema_FieldId FieldId, const TArray<uint8>& Value)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, "uint32 BytesLength = Value.Num();"));
            builder.AppendLine(Text.Indent(2, "uint8* ByteBuffer = Schema_AllocateBuffer(SchemaObject, BytesLength);"));
            builder.AppendLine(Text.Indent(2, "memcpy(ByteBuffer, Value.GetData(), BytesLength);"));
            builder.AppendLine(Text.Indent(2, "Schema_AddBytes(SchemaObject, FieldId, ByteBuffer, BytesLength);"));
            builder.AppendLine(Text.Indent(1, "}"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $@"void AddString(Schema_Object* SchemaObject, Schema_FieldId FieldId, FString Value)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, "const char* Text = TCHAR_TO_ANSI(*Value);"));
            builder.AppendLine(Text.Indent(2, "uint32 TextLength = sizeof(char) * strlen(Text); // ensure to exclude null-terminator"));
            builder.AppendLine(Text.Indent(2, "uint8* TextBuffer = Schema_AllocateBuffer(SchemaObject, TextLength);"));
            builder.AppendLine(Text.Indent(2, "memcpy(TextBuffer, Text, TextLength);"));
            builder.AppendLine(Text.Indent(2, "Schema_AddBytes(SchemaObject, FieldId, TextBuffer, TextLength);"));
            builder.AppendLine(Text.Indent(1, "}"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $@"TArray<uint8> GetBytes(const Schema_Object* SchemaObject, Schema_FieldId FieldId)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, "uint32 BytesLength = Schema_GetBytesLength(SchemaObject, FieldId);"));
            builder.AppendLine(Text.Indent(2, "const uint8* Bytes = Schema_GetBytes(SchemaObject, FieldId);"));
            builder.AppendLine(Text.Indent(2, "return TArray<uint8>(Bytes, BytesLength);"));
            builder.AppendLine(Text.Indent(1, "}"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $@"FString GetString(const Schema_Object* SchemaObject, Schema_FieldId FieldId)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, "uint32 TextLength = Schema_GetBytesLength(SchemaObject, FieldId);"));
            builder.AppendLine(Text.Indent(2, "const uint8* Text = Schema_GetBytes(SchemaObject, FieldId); "));
            builder.AppendLine(Text.Indent(2, "return FString(TextLength, ANSI_TO_TCHAR(reinterpret_cast<const char*>(Text)));"));
            builder.AppendLine(Text.Indent(1, "}"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $@"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<TArray<uint8>> GetBytesList(const Schema_Object* SchemaObject, Schema_FieldId FieldId)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, $"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<TArray<uint8>> BytesList{{}};"));
            builder.AppendLine(Text.Indent(2, $"auto ListSize =  Schema_GetBytesCount(SchemaObject, FieldId);"));
            builder.AppendLine(Text.Indent(2, "for (uint32 i = 0; i < ListSize; ++i)"));
            builder.AppendLine(Text.Indent(2, "{"));
            builder.AppendLine(Text.Indent(3, "uint32 BytesLength = Schema_IndexBytesLength(SchemaObject, FieldId, i);"));
            builder.AppendLine(Text.Indent(3, "const uint8* Bytes = Schema_IndexBytes(SchemaObject, FieldId, i);"));
            builder.AppendLine(Text.Indent(3, "BytesList.Add(TArray<uint8>(Bytes, BytesLength));"));
            builder.AppendLine(Text.Indent(2, "}"));
            builder.AppendLine(Text.Indent(2, "return BytesList;"));
            builder.AppendLine(Text.Indent(1, "}"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $@"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<FString> GetStringList(const Schema_Object* SchemaObject, Schema_FieldId FieldId)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, $"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}<FString> StringList{{}};"));
            builder.AppendLine(Text.Indent(2, $"auto ListSize =  Schema_GetBytesCount(SchemaObject, FieldId);"));
            builder.AppendLine(Text.Indent(2, "for (uint32 i = 0; i < ListSize; ++i)"));
            builder.AppendLine(Text.Indent(2, "{"));
            builder.AppendLine(Text.Indent(3, "uint32 TextLength = Schema_IndexBytesLength(SchemaObject, FieldId, i);"));
            builder.AppendLine(Text.Indent(3, "const uint8* Text = Schema_IndexBytes(SchemaObject, FieldId, i);"));
            builder.AppendLine(Text.Indent(3, "StringList.Add(FString(TextLength, ANSI_TO_TCHAR(reinterpret_cast<const char*>(Text))));"));
            builder.AppendLine(Text.Indent(2, "}"));
            builder.AppendLine(Text.Indent(2, "return StringList;"));
            builder.AppendLine(Text.Indent(1, "}"));

            builder.AppendLine("} // namespace utils");
            builder.AppendLine("} // namespace improbable");
            builder.Append(Environment.NewLine);

            builder.AppendLine($"inline uint32 GetTypeHash(const TArray<uint8>& Value)");
            builder.AppendLine($"{{");
            builder.AppendLine(Text.Indent(1, $"size_t Result = 1327;"));
            builder.AppendLine(Text.Indent(1, $"for (const auto& item : Value)"));
            builder.AppendLine(Text.Indent(1, $"{{"));
            builder.AppendLine(Text.Indent(2, $"Result = (Result * 977) + GetTypeHash(item);"));
            builder.AppendLine(Text.Indent(1, $"}}"));
            builder.AppendLine(Text.Indent(1, $"return Result;"));
            builder.AppendLine($"}}");

            return builder.ToString();
        }
    }
}

