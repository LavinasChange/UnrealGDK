using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Improbable.CodeGen.Base;

namespace Improbable.CodeGen.Unreal
{
    public static class SourceGenerator
    {
        public static string GenerateSource(TypeDescription type, List<TypeDescription> types, Dictionary<string, TypeGeneratedCode> allGeneratedTypeContent, Bundle bundle)
        {
            var builder = new StringBuilder();

            var sourceRef = bundle.SchemaBundle.SourceMapV1.SourceReferences[type.QualifiedName];
            var allNestedTypes = Types.GetRecursivelyNestedTypes(type);
            var allNestedEnums = Types.GetRecursivelyNestedEnums(type);
            var typeNamespaces = Text.GetNamespaceFromTypeName(type.QualifiedName);

            builder.AppendLine($"// Generated by {UnrealGenerator.GeneratorTitle}");
            builder.Append(Environment.NewLine);

            builder.AppendLine($"#include \"{UnrealGenerator.RelativeIncludePrefix}{Types.TypeToHeaderFilename(type.QualifiedName)}\"");
            builder.AppendLine($"#include \"{UnrealGenerator.RelativeIncludePrefix}{MapEquals.HeaderName}\"");
            builder.Append(Environment.NewLine);

            builder.AppendLine($"// Generated from {sourceRef.FilePath}({sourceRef.Line},{sourceRef.Column})");
            builder.AppendLine(string.Join(Environment.NewLine, typeNamespaces.Select(t => $"namespace {t} {{")));
            builder.Append(Environment.NewLine);

            builder.AppendLine(GenerateTypeFunctions(type.Name, type, bundle));

            if (type.IsComponent)
            {
                builder.AppendLine(GenerateComponentUpdateFunctions(type.Name, type, bundle));
            }

            // Nested type functions
            builder.AppendJoin(Environment.NewLine, allNestedTypes.Select(nestedType => GenerateTypeFunctions(Types.GetTypeClassDefinitionName(nestedType.QualifiedName, bundle), types.Find(t => t.QualifiedName == nestedType.QualifiedName), bundle)));

            // Hash function definitions
            builder.AppendLine(GenerateHashFunction(type, bundle));
            builder.AppendJoin(Environment.NewLine, allNestedTypes.Select(nestedType => GenerateHashFunction(types.Find(t => t.QualifiedName == nestedType.QualifiedName), bundle)));
            builder.AppendJoin(Environment.NewLine, allNestedEnums.Select(nestedEnum => GenerateHashFunction(nestedEnum, bundle)));

            builder.AppendLine(string.Join(Environment.NewLine, typeNamespaces.Reverse().Select(t => $"}} // namespace {t}")));
            builder.Append(Environment.NewLine);

            return builder.ToString();
        }

        private static string GenerateTypeFunctions(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GenerateConstructors(name, type, bundle));
            builder.AppendLine(GenerateEquatables(name, type));
            builder.AppendLine(GeneratedFieldAccessors(name, type, bundle));
            builder.AppendLine(GenerateSerializerFunction(name, type, bundle));
            builder.AppendLine(GenerateDeserializerFunction(name, type, bundle));
            return builder.ToString();
        }

        private static string GenerateConstructors(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();

            // If type has members, generate full constructor
            if (type.Fields.Count > 0)
            {
                var parameters = string.Join($", {Environment.NewLine}", type.Fields.Select(f => $"{Types.GetFieldTypeAsCpp(f, bundle)} {Text.SnakeCaseToPascalCase(f.Identifier.Name)}"));
                var initList = string.Join($"{Environment.NewLine}, ", type.Fields.Select(f => $"_{Text.SnakeCaseToPascalCase(f.Identifier.Name)}{{ {Text.SnakeCaseToPascalCase(f.Identifier.Name)} }}"));
                builder.AppendLine($@"{name}::{name}(");
                builder.AppendLine(Text.Indent(1, $"{parameters})"));
                builder.AppendLine($": {initList} {{}}");
            }
            builder.Append(Environment.NewLine);
            builder.AppendLine($@"{name}::{name}() {{}}");

            return builder.ToString();
        }

        private static string GenerateEquatables(string name, TypeDescription type, string typeNameSuffix = "")
        {
            var otherObjectName = "Value";
            var builder = new StringBuilder();

            builder.AppendLine($"bool {name + typeNameSuffix}::operator==(const {name + typeNameSuffix}& {otherObjectName}) const");
            builder.AppendLine("{");
            if (type.Fields.Count == 0)
            {
                builder.AppendLine(Text.Indent(1, "return true;"));
            }
            else
            {
                builder.AppendLine(Text.Indent(1, $"return {string.Join($@" && {Environment.NewLine}", type.Fields.Select(f => Types.GetFieldDefinitionEquals(f, $"_{Text.SnakeCaseToPascalCase(f.Identifier.Name)}", otherObjectName)))};"));
            }
            builder.AppendLine("}");
            builder.Append(Environment.NewLine);

            builder.AppendLine($"bool {name + typeNameSuffix}::operator!=(const {name + typeNameSuffix}& {otherObjectName}) const");
            builder.AppendLine("{");
            builder.AppendLine(Text.Indent(1, $"return !operator== ({otherObjectName});"));
            builder.AppendLine("}");

            return builder.ToString();
        }

        private static string GeneratedFieldAccessors(string name, TypeDescription type, Bundle bundle)
        {
            var fields = new StringBuilder();

            foreach (var field in type.Fields)
            {
                var qualifiedFieldType = Types.GetFieldTypeAsCpp(field, bundle);
                fields.AppendLine($@"{Types.GetConstAccessorTypeModification(field, bundle)} {name}::Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}() const");
                fields.AppendLine("{");
                fields.AppendLine(Text.Indent(1, $"return _{Text.SnakeCaseToPascalCase(field.Identifier.Name)};"));
                fields.AppendLine("}");
                fields.Append(Environment.NewLine);
                fields.AppendLine($@"{qualifiedFieldType}& {name}::Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}()");
                fields.AppendLine("{");
                fields.AppendLine(Text.Indent(1, $"return _{Text.SnakeCaseToPascalCase(field.Identifier.Name)};"));
                fields.AppendLine("}");
                fields.Append(Environment.NewLine);
                fields.AppendLine($@"{name}& {name}::Set{Text.SnakeCaseToPascalCase(field.Identifier.Name)}({Types.GetConstAccessorTypeModification(field, bundle)} Value)");
                fields.AppendLine("{");
                fields.AppendLine(Text.Indent(1, $"_{Text.SnakeCaseToPascalCase(field.Identifier.Name)} = Value;"));
                fields.AppendLine(Text.Indent(1, $"return *this;"));
                fields.AppendLine("}");
            }

            return fields.ToString();
        }

        private static string GenerateSerializerFunction(string name, TypeDescription type, Bundle bundle)
        {
            var argType = type.IsComponent ? "Schema_ComponentData" : "Schema_Object";
            var argName = type.IsComponent ? "ComponentData" : "SchemaObject";
            var componentFieldsName = "FieldsObject";
            var targetSchemaObject = type.IsComponent ? componentFieldsName : argName;

            var builder = new StringBuilder();

            // Trivial definitions if type has no fields or events
            if (type.Fields.Count == 0 && type.Events == null)
            {
                builder.AppendLine($"void {name}::Serialize({argType}* {argName}) const {{}}");
                return builder.ToString();
            }

            builder.AppendLine($"void {name}::Serialize({argType}* {argName}) const");
            builder.AppendLine("{");
            if (type.IsComponent)
            {
                builder.AppendLine(Text.Indent(1, $"Schema_Object* {componentFieldsName} = Schema_GetComponentDataFields({argName});"));
                builder.Append(Environment.NewLine);
            }
            foreach (var field in type.Fields)
            {
                builder.AppendLine(Text.Indent(1, $"// serializing field {Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {field.FieldId}"));
                builder.AppendLine(Text.Indent(1, Serialization.GetFieldSerialization(field, targetSchemaObject, $"_{Text.SnakeCaseToPascalCase(field.Identifier.Name)}", bundle)));
                builder.Append(Environment.NewLine);
            }
            builder.AppendLine("}");
            
            return builder.ToString();
        }

        private static string GenerateDeserializerFunction(string name, TypeDescription type, Bundle bundle)
        {
            var argType = type.IsComponent ? "Schema_ComponentData" : "Schema_Object";
            var argName = type.IsComponent ? "ComponentData" : "SchemaObject";
            var componentFieldsName = "FieldsObject";
            var targetSchemaObject = type.IsComponent ? componentFieldsName : argName;

            var builder = new StringBuilder();

            // Trivial definitions if type has no members
            if (type.Fields.Count == 0)
            {
                builder.AppendLine($"{name} {name}::Deserialize({argType}* {argName})");
                builder.AppendLine("{");
                builder.AppendLine(Text.Indent(1, $"return {name}::Create();"));
                builder.AppendLine("}");

                return builder.ToString();
            }
            
            builder.AppendLine($"{name} {name}::Deserialize({argType}* {argName})");
            builder.AppendLine("{");

            if (type.IsComponent)
            {
                builder.AppendLine(Text.Indent(1, $"Schema_Object* {componentFieldsName} = Schema_GetComponentDataFields({argName});"));
                builder.Append(Environment.NewLine);
            }

            builder.AppendLine(Text.Indent(1, $"{name} Data;"));
            builder.Append(Environment.NewLine);

            foreach (var field in type.Fields)
            {
                builder.AppendLine(Text.Indent(1, $"// deserializing field {Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {field.FieldId}"));
                builder.AppendLine(Text.Indent(1, Serialization.GetFieldDeserialization(field, targetSchemaObject, $"Data._{Text.SnakeCaseToPascalCase(field.Identifier.Name)}", bundle, true)));
            }

            builder.AppendLine(Text.Indent(1, "return Data;"));
            builder.AppendLine("}");

            return builder.ToString();
        }

        private static string GenerateComponentUpdateFunctions(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();
            builder.AppendLine(GenerateEquatables(name, type, "::Update"));
            builder.AppendLine(GenerateComponentUpdateConstructionAndApply(name, type));
            builder.AppendLine(GenerateComponentUpdateFieldAndEventAccessors(name, type, bundle));
            builder.AppendLine(GenerateComponentUpdateSerializationFunction(name, type, bundle));
            builder.AppendLine(GenerateComponentUpdateDeserializationFunction(name, type, bundle));
            return builder.ToString();
        }

        private static string GenerateComponentUpdateConstructionAndApply(string name, TypeDescription type)
        {
            var builder = new StringBuilder();

            builder.AppendLine($@"{name}::Update {name}::Update::FromInitialData(const {name}& Data)");
            builder.AppendLine("{");
            builder.AppendLine(Text.Indent(1, $"{name}::Update Update;"));
            builder.AppendLine(Text.Indent(1, string.Join(Environment.NewLine, type.Fields.Select(f => $"Update._{Text.SnakeCaseToPascalCase(f.Identifier.Name)} = Data.Get{Text.SnakeCaseToPascalCase(f.Identifier.Name)}();"))));
            builder.AppendLine(Text.Indent(1, $"return Update;"));
            builder.AppendLine("}");
            builder.Append(Environment.NewLine);

            builder.AppendLine($@"{name} {name}::Update::ToInitialData() const");
            builder.AppendLine("{");
            builder.AppendLine(Text.Indent(1, $@"return {name}("));
            builder.AppendLine(Text.Indent(1, $"{string.Join($",{Environment.NewLine}", type.Fields.Select(f => Text.Indent(1, $"*_{Text.SnakeCaseToPascalCase(f.Identifier.Name)}")))});"));
            builder.AppendLine("}");
            builder.Append(Environment.NewLine);

            builder.AppendLine($@"void {name}::Update::ApplyTo({name}& Data) const");
            builder.AppendLine("{");
            foreach (var field in type.Fields)
            {
                builder.AppendLine(Text.Indent(1, $@"if (_{Text.SnakeCaseToPascalCase(field.Identifier.Name)})"));
                builder.AppendLine(Text.Indent(1, "{"));
                builder.AppendLine(Text.Indent(2, $@"Data.Set{Text.SnakeCaseToPascalCase(field.Identifier.Name)}(*_{Text.SnakeCaseToPascalCase(field.Identifier.Name)});"));
                builder.AppendLine(Text.Indent(1, "}"));

            }
            builder.AppendLine("}");

            return builder.ToString().TrimEnd();
        }

        private static string GenerateComponentUpdateFieldAndEventAccessors(string name, TypeDescription type, Bundle bundle)
        {
            var fieldsAndEventsAccessors = new StringBuilder();

            foreach (var field in type.Fields)
            {
                var qualifiedFieldType = Types.GetFieldTypeAsCpp(field, bundle);
                fieldsAndEventsAccessors.AppendLine($@"const {Types.CollectionTypesToQualifiedTypes[Types.Collection.Option]}<{qualifiedFieldType}>& {name}::Update::Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}() const");
                fieldsAndEventsAccessors.AppendLine("{");
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"return _{Text.SnakeCaseToPascalCase(field.Identifier.Name)};"));
                fieldsAndEventsAccessors.AppendLine("}");
                fieldsAndEventsAccessors.Append(Environment.NewLine);

                fieldsAndEventsAccessors.AppendLine($@"{Types.CollectionTypesToQualifiedTypes[Types.Collection.Option]}<{qualifiedFieldType}>& {name}::Update::Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}()");
                fieldsAndEventsAccessors.AppendLine("{");
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"return _{Text.SnakeCaseToPascalCase(field.Identifier.Name)};"));
                fieldsAndEventsAccessors.AppendLine("}");
                fieldsAndEventsAccessors.Append(Environment.NewLine);

                fieldsAndEventsAccessors.AppendLine($@"{name}::Update& {name}::Update::Set{Text.SnakeCaseToPascalCase(field.Identifier.Name)}({qualifiedFieldType} value)");
                fieldsAndEventsAccessors.AppendLine("{");
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"_{Text.SnakeCaseToPascalCase(field.Identifier.Name)} = value;"));
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"return *this;"));
                fieldsAndEventsAccessors.AppendLine("}");
                fieldsAndEventsAccessors.Append(Environment.NewLine);
            }

            foreach (var _event in type.Events)
            {
                var qualifiedEventType = Types.GetQualifiedTypeName(_event.Type, bundle);
                fieldsAndEventsAccessors.AppendLine($@"const {Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}< {qualifiedEventType} >& {name}::Update::Get{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List() const");
                fieldsAndEventsAccessors.AppendLine("{");
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"return _{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List;"));
                fieldsAndEventsAccessors.AppendLine("}");
                fieldsAndEventsAccessors.Append(Environment.NewLine);

                fieldsAndEventsAccessors.AppendLine($@"{Types.CollectionTypesToQualifiedTypes[Types.Collection.List]}< {qualifiedEventType} >& {name}::Update::Get({Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List()");
                fieldsAndEventsAccessors.AppendLine("{");
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"return _{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List;"));
                fieldsAndEventsAccessors.AppendLine("}");
                fieldsAndEventsAccessors.Append(Environment.NewLine);

                fieldsAndEventsAccessors.AppendLine($@"{ name}::Update& {name}::Update::Add{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}(const {qualifiedEventType}& Value)");
                fieldsAndEventsAccessors.AppendLine("{");
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"_{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List.Add(Value);"));
                fieldsAndEventsAccessors.AppendLine(Text.Indent(1, $"return *this;"));
                fieldsAndEventsAccessors.AppendLine("}");
                fieldsAndEventsAccessors.Append(Environment.NewLine);
            }

            return fieldsAndEventsAccessors.ToString().TrimEnd();
        }

        private static string GenerateComponentUpdateSerializationFunction(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();
            var updatesObjectName = "UpdatesObject";
            var eventsObjectName = "EventsObject";

            // Trivial definitions if type has no fields or events
            if (type.Fields.Count == 0 && type.Events.Count == 0)
            {
                builder.AppendLine($"void {name}::Update::Serialize(Schema_ComponentUpdate* ComponentUpdate) const {{}}");
                builder.Append(Environment.NewLine);
                return builder.ToString();
            }

            builder.AppendLine($"void {name}::Update::Serialize(Schema_ComponentUpdate* ComponentUpdate) const");
            builder.AppendLine("{");

            if (type.Fields.Count > 0 )
            {
                builder.AppendLine(Text.Indent(1, $"Schema_Object* {updatesObjectName} = Schema_GetComponentUpdateFields(ComponentUpdate);"));
            }

            if (type.Events.Count > 0)
            {
                builder.AppendLine(Text.Indent(1, $"Schema_Object* {eventsObjectName} = Schema_GetComponentUpdateEvents(ComponentUpdate);"));
            }
            builder.Append(Environment.NewLine);

            foreach (var field in type.Fields)
            {
                builder.AppendLine(Text.Indent(1, $"// serializing field {Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {field.FieldId}"));
                builder.AppendLine(Text.Indent(1, $@"if (_{Text.SnakeCaseToPascalCase(field.Identifier.Name)}.IsSet())"));
                builder.AppendLine(Text.Indent(1, "{"));
                if (field.TypeSelector != FieldType.Singular) // only check if lists, maps, or options are fields to be cleared
                {
                    builder.AppendLine(Text.Indent(2, $"if ({Serialization.GetFieldClearingCheck(field)})"));
                    builder.AppendLine(Text.Indent(2, "{"));
                    builder.AppendLine(Text.Indent(3, $"Schema_AddComponentUpdateClearedField(ComponentUpdate, {field.FieldId});"));
                    builder.AppendLine(Text.Indent(2, "}"));
                    builder.AppendLine(Text.Indent(2, "else"));
                    builder.AppendLine(Text.Indent(2, "{"));
                    builder.AppendLine(Text.Indent(3, Serialization.GetFieldSerialization(field, updatesObjectName, $"(*_{Text.SnakeCaseToPascalCase(field.Identifier.Name)})", bundle)));
                    builder.AppendLine(Text.Indent(2, "}"));
                }
                else
                {
                    builder.AppendLine(Text.Indent(2, Serialization.GetFieldSerialization(field, updatesObjectName, $"(*_{Text.SnakeCaseToPascalCase(field.Identifier.Name)})", bundle)));

                }
                builder.AppendLine(Text.Indent(1, "}"));
                builder.Append(Environment.NewLine);
            }

            foreach (var _event in type.Events)
            {
                var eventType = Types.GetQualifiedTypeName(_event.Type.Type);
                builder.AppendLine(Text.Indent(1, $"// serializing event {Text.SnakeCaseToPascalCase(_event.Identifier.Name)} = {_event.EventIndex}"));
                builder.AppendLine(Text.Indent(1, $"for (const {eventType}& Element : _{Text.SnakeCaseToPascalCase(_event.Identifier.Name)}List)"));
                builder.AppendLine(Text.Indent(1, "{"));
                builder.AppendLine(Text.Indent(2, $"Element.Serialize(Schema_AddObject({eventsObjectName}, {_event.EventIndex}));"));
                builder.AppendLine(Text.Indent(1, "}"));
                builder.Append(Environment.NewLine);
            }
            builder.AppendLine($"}}");

            return builder.ToString();
        }

        private static string GenerateComponentUpdateDeserializationFunction(string name, TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();

            // Trivial definitions if type has no members
            if (type.Fields.Count + type.Events.Count == 0)
            {
                builder.AppendLine($"{name}::Update {name}::Update::Deserialize(Schema_ComponentUpdate* ComponentUpdate)");
                builder.AppendLine("{");
                builder.AppendLine(Text.Indent(1, $"return {name}::Update::Create();"));
                builder.AppendLine("}");
                return builder.ToString();
            }

            var updatesObjectName = "updates_object";
            var eventsObjectName = "events_object";
            var targetObjectName = "data";

            builder.AppendLine($@"{name}::Update {name}::Update::Deserialize(Schema_ComponentUpdate* ComponentUpdate)");
            builder.AppendLine("{");
            if (type.Fields.Count > 0)
            {
                builder.AppendLine(Text.Indent(1, $"Schema_Object* {updatesObjectName} = Schema_GetComponentUpdateFields(ComponentUpdate);"));
            }

            if (type.Events.Count > 0)
            {
                builder.AppendLine(Text.Indent(1, $"Schema_Object* {eventsObjectName} = Schema_GetComponentUpdateEvents(ComponentUpdate);"));
            }

            // setup fields to clear
            builder.AppendLine(Text.Indent(1, $"auto FieldsToClear = new Schema_FieldId[Schema_GetComponentUpdateClearedFieldCount(ComponentUpdate)];"));
            builder.AppendLine(Text.Indent(1, $"Schema_GetComponentUpdateClearedFieldList(ComponentUpdate, FieldsToClear);"));
            builder.AppendLine(Text.Indent(1, $"std::set<Schema_FieldId> FieldsToClearSet(FieldsToClear, FieldsToClear + sizeof(FieldsToClear) / sizeof(Schema_FieldId));"));
            builder.Append(Environment.NewLine);

            builder.AppendLine(Text.Indent(1, $"{name}::Update {targetObjectName};"));
            builder.Append(Environment.NewLine);

            foreach (var field in type.Fields)
            {
                builder.AppendLine(Text.Indent(1, $"// deserializing field {Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {field.FieldId}"));
                builder.AppendLine(Text.Indent(1, $"if ({Serialization.GetFieldTypeCount(field, updatesObjectName)} > 0)"));
                builder.AppendLine(Text.Indent(1, "{"));
                builder.AppendLine(Text.Indent(2, Serialization.GetFieldDeserialization(field, updatesObjectName, $"{targetObjectName}._{Text.SnakeCaseToPascalCase(field.Identifier.Name)}", bundle, false, true)));
                builder.AppendLine(Text.Indent(1, "}"));
                if (field.TypeSelector != FieldType.Singular) // only check if lists, maps, or options should be cleared
                {
                    var fieldType = Types.GetFieldTypeAsCpp(field, bundle);
                    builder.AppendLine(Text.Indent(1, $"else if (FieldsToClearSet.count({field.FieldId}))"));
                    builder.AppendLine(Text.Indent(1, "{"));
                    builder.AppendLine(Text.Indent(2, $"{targetObjectName}._{Text.SnakeCaseToPascalCase(field.Identifier.Name)} = {{}};"));
                    builder.AppendLine(Text.Indent(1, "}"));
                }
                builder.Append(Environment.NewLine);
            }

            // get fields to clear
            builder.AppendLine(Text.Indent(1, $"for (auto i = 0; i < Schema_GetComponentUpdateClearedFieldCount(component_update); ++i)"));
            builder.AppendLine(Text.Indent(1, "{"));
            builder.AppendLine(Text.Indent(2, "auto clearedFieldId = Schema_IndexComponentUpdateClearedField(component_update, i);"));
            builder.AppendLine(Text.Indent(2, ""));
            builder.AppendLine(Text.Indent(1, "}"));

            foreach (var _event in type.Events)
            {
                builder.AppendLine(Text.Indent(1, $"// deserializing event {Text.SnakeCaseToPascalCase(_event.Identifier.Name)} = {_event.EventIndex}"));
                builder.AppendLine(Text.Indent(1, Serialization.GetEventDeserialization(_event, eventsObjectName, targetObjectName)));
                builder.Append(Environment.NewLine);
            }

            builder.AppendLine(Text.Indent(1, $"return {targetObjectName};"));
            builder.AppendLine("}");

            return builder.ToString();
        }

        private static string GenerateHashFunction(TypeDescription type, Bundle bundle)
        {
            var builder = new StringBuilder();
            builder.AppendLine($"uint32 GetTypeHash(const {Types.GetTypeClassDefinitionQualifiedName(type.QualifiedName, bundle)}& Value)");
            builder.AppendLine("{");
            builder.AppendLine(Text.Indent(1, "uint32 Result = 1327;"));
            foreach (var field in type.Fields)
            {
                builder.AppendLine(Text.Indent(1, $"{Types.GetFieldDefinitionHash($"Value.Get{Text.SnakeCaseToPascalCase(field.Identifier.Name)}()", field, "Result", bundle)}"));
            }
            builder.AppendLine(Text.Indent(1, "return Result;"));
            builder.AppendLine("}");
            return builder.ToString();
        }

        private static string GenerateHashFunction(EnumDefinition enumDef, Bundle bundle)
        {
            var builder = new StringBuilder();
            builder.AppendLine($"uint32 GetTypeHash(const {Types.GetTypeClassDefinitionQualifiedName(enumDef.Identifier.QualifiedName, bundle)}& Value)");
            builder.AppendLine("{");
            builder.AppendLine(Text.Indent(1, "return static_cast<size_t>(Value);"));
            builder.AppendLine("}");
            return builder.ToString();
        }
    }
}
